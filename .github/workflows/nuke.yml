name: Aggressive Bounty Funnel (6h)

on:
  workflow_dispatch:
    inputs:
      top_n:
        description: Top hosts to aggressively scan
        required: true
        default: "150"
      chunks:
        description: Parallel chunks for aggressive scan
        required: true
        default: "6"
      aggressive:
        description: Enable intrusive vuln templates (only if scope allows)
        required: true
        default: "true"
      httpx_threads:
        description: httpx threads
        required: true
        default: "200"
      nuclei_rate:
        description: nuclei rate-limit
        required: true
        default: "120"
      do_dirfuzz:
        description: Run a short dir fuzz (ffuf) on live hosts (true/false)
        required: true
        default: "false"
      ffuf_wordlist:
        description: Path to ffuf wordlist (kept small by default)
        required: true
        default: "repo-wordlists/small-admin.txt"

permissions:
  contents: read

env:
  # Use an absolute GOBIN so `go install` never fails with "must be an absolute path".
  # /home/runner is the homedir used on GitHub-hosted ubuntu runners.
  GOBIN: /home/runner/.local/bin
  TMP_NUCLEI: /tmp/nuclei-templates

jobs:
  prepare:
    runs-on: ubuntu-22.04
    outputs:
      top_hosts_path: ${{ steps.top.outputs.path || '' }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go (pin 1.24.x)
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'

      - name: Cache go build & modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
            ${{ env.GOBIN }}
          key: go-cache-${{ runner.os }}-${{ hashFiles('**/go.sum') || hashFiles('**/*.mod') || 'nohash' }}

      - name: Install deps (Python + subfinder)
        run: |
          set -euxo pipefail

          # system packages
          sudo apt-get update -y || true
          sudo apt-get install -y --no-install-recommends jq curl python3 python3-pip ca-certificates git unzip gcc

          # python deps
          pip3 install --user python-dateutil dnspython requests

          # ensure GOBIN exists (absolute path from env)
          mkdir -p "${GOBIN}"
          echo "${GOBIN}" >> "$GITHUB_PATH"
          export PATH="${GOBIN}:$PATH"

          # tolerate go checks / flaky proxy
          go env -w GOSUMDB=off || true
          go env -w GOPROXY=https://proxy.golang.org,https://goproxy.io,direct || true

          # robust go installer (exponential backoff)
          go_install_retry() {
            pkg="$1"; tries=6; wait=3
            for i in $(seq 1 $tries); do
              echo "install attempt $i -> $pkg"
              if GOBIN="${GOBIN}" go install "$pkg"; then
                echo "ok: $pkg"
                return 0
              fi
              echo "failed attempt $i for $pkg; sleeping $wait"
              sleep $wait
              wait=$((wait*2))
            done
            echo "::error::failed to install $pkg after $tries tries"
            return 1
          }

          # install subfinder (required for discovery)
          if ! command -v subfinder >/dev/null 2>&1; then
            go_install_retry github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
          fi

          # fail early and loudly if subfinder still missing (helps debugging)
          if ! command -v subfinder >/dev/null 2>&1; then
            echo "::error::subfinder not found after install (GOBIN=${GOBIN})"
            ls -la "${GOBIN}" || true
            env | grep -E 'GOBIN|PATH' || true
            exit 1
          fi

          # show version (non-fatal) for verification
          subfinder -version || subfinder -h || true

      - name: Discovery (crt.sh + subfinder per-seed, filtered)
        id: disco
        run: |
          set -euxo pipefail
          mkdir -p tmp/disco
          : > tmp/candidates.raw
          while read -r SEED; do
            [ -z "$SEED" ] && continue
            echo "[crt.sh] querying $SEED" >&2
            curl -fsS "https://crt.sh/?q=%25.$SEED&output=json" \
              | jq -r '.[].name_value' 2>/dev/null \
              | sed 's/\*\.//g' > tmp/disco/crt.$SEED.txt || true
            echo "[subfinder] running for $SEED" >&2
            # safeguard: if subfinder missing, the command will exit non-fatally because of "|| true"
            subfinder -d "$SEED" -silent > tmp/disco/subfinder.$SEED.txt || true
            # combine and keep only suffix-matching entries
            cat tmp/disco/crt.$SEED.txt tmp/disco/subfinder.$SEED.txt \
              | sed 's#^https\?://##' | cut -d/ -f1 | sed 's/^www\.//' \
              | awk -v s=".$SEED" 'tolower($0) ~ s"$" {print tolower($0)}' >> tmp/candidates.raw || true
          done < seeds.txt
          sort -u tmp/candidates.raw > tmp/candidates.txt || true
          echo "candidates: $(wc -l < tmp/candidates.txt || echo 0)"

      - name: Enrich + score → top list
        id: top
        run: |
          set -euxo pipefail
          mkdir -p tmp/enrich
          python3 scripts/enrich_score.py tmp/candidates.txt --top "${{ github.event.inputs.top_n }}" --cap 1500 --workers 35 --timeout 4
          echo "path=tmp/enrich/top_hosts.txt" >> $GITHUB_OUTPUT

      - name: Upload enrichment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: enrichment
          path: |
            tmp/enrich/top_hosts.txt
            tmp/enrich/top.json
            tmp/enrich/all.json

  scan:
    needs: prepare
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        chunk: [1]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go (scan job) - pin 1.24.x
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.6'

      - name: Install scan tools (httpx, nuclei, ffuf) robust
        run: |
          set -euxo pipefail
          # ensure GOBIN available and exposed to PATH
          mkdir -p "${GOBIN}"
          echo "${GOBIN}" >> "$GITHUB_PATH"
          export PATH="${GOBIN}:$PATH"

          # tolerant go config
          go env -w GOSUMDB=off || true
          go env -w GOPROXY=https://proxy.golang.org,https://goproxy.io,direct || true

          go_install_retry() {
            pkg="$1"; tries=6; wait=3
            for i in $(seq 1 $tries); do
              echo "install attempt $i -> $pkg"
              if GOBIN="${GOBIN}" go install "$pkg"; then
                echo "ok: $pkg"
                return 0
              fi
              echo "failed; sleeping $wait"
              sleep $wait
              wait=$((wait*2))
            done
            echo "::warning::go install failed for $pkg after $tries attempts"
            return 1
          }

          command -v httpx >/dev/null 2>&1 || go_install_retry github.com/projectdiscovery/httpx/cmd/httpx@latest
          # FIXED: install nuclei v3 (old v2 path caused v2.9.15 to be installed)
          command -v nuclei >/dev/null 2>&1 || go_install_retry github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest
          command -v ffuf >/dev/null 2>&1 || (go_install_retry github.com/ffuf/ffuf@latest || true)

          # smoke checks
          httpx -version || echo "httpx not available"
          nuclei -version || echo "nuclei not available"
          ffuf -version || echo "ffuf not available"

      - name: Fetch nuclei templates (git then zip fallback)
        run: |
          set -euxo pipefail
          rm -rf "${TMP_NUCLEI}"
          for attempt in 1 2 3; do
            echo "[template fetch] attempt $attempt"
            if git clone --depth 1 https://github.com/projectdiscovery/nuclei-templates "${TMP_NUCLEI}"; then break; fi
            sleep $((attempt*5))
          done
          if [ ! -d "${TMP_NUCLEI}" ] || [ -z "$(ls -A "${TMP_NUCLEI}" 2>/dev/null || true)" ]; then
            echo "[template fetch] zip fallback"
            curl -fsSL https://github.com/projectdiscovery/nuclei-templates/archive/refs/heads/master.zip -o /tmp/nuclei-templates.zip || true
            unzip -q /tmp/nuclei-templates.zip -d /tmp || true
            [ -d /tmp/nuclei-templates-master ] && mv /tmp/nuclei-templates-master "${TMP_NUCLEI}" || true
          fi
          if [ -d "${TMP_NUCLEI}" ] && [ -n "$(ls -A "${TMP_NUCLEI}" 2>/dev/null || true)" ]; then
            echo "[template fetch] success; templates: $(find "${TMP_NUCLEI}" -type f | wc -l)"
            nuclei -update-templates || true
          else
            echo "::warning:: nuclei templates missing -> scanning will skip templates"
          fi

      - name: Download top hosts
        uses: actions/download-artifact@v4
        with:
          name: enrichment
          path: tmp/enrich

      - name: Split into chunks
        id: split
        run: |
          set -euxo pipefail
          mkdir -p tmp/split
          c=${{ github.event.inputs.chunks }}
          nl=$(wc -l < tmp/enrich/top_hosts.txt || echo 0)
          if [ "$nl" -eq 0 ]; then
            echo "::warning:: No top hosts found; exiting early" && exit 0
          fi
          split -n l/$c tmp/enrich/top_hosts.txt tmp/split/part.
          echo "parts=$(ls tmp/split/part.* | tr '\n' ' ')" >> $GITHUB_OUTPUT

      - name: Run scans (loop parts; prefilter + single nuclei)
        env:
          THREADS: ${{ github.event.inputs.httpx_threads }}
          RATE: ${{ github.event.inputs.nuclei_rate }}
          AGGR: ${{ github.event.inputs.aggressive }}
          DO_DIRFUZZ: ${{ github.event.inputs.do_dirfuzz }}
          FFUF_WORDLIST: ${{ github.event.inputs.ffuf_wordlist }}
        run: |
          set -euxo pipefail
          mkdir -p outputs tmp/top_live_hosts
          for p in tmp/split/part.*; do
            partname="$(basename "$p")"
            echo "=== chunk: $partname ==="
            echo "[httpx] verifying live hosts from $p"
            cat "$p" | httpx -silent -threads "${THREADS}" -timeout 8 -ports 80,443 -status-code -title -json -o "outputs/httpx.$partname.jsonl" || true
            if [ -s "outputs/httpx.$partname.jsonl" ]; then
              jq -r '.host' "outputs/httpx.$partname.jsonl" > "tmp/top_live_hosts.$partname.txt" || true
            else
              cp "$p" "tmp/top_live_hosts.$partname.txt" || true
            fi

            if [ "${DO_DIRFUZZ:-false}" = "true" ] && command -v ffuf >/dev/null 2>&1; then
              if [ -f "${FFUF_WORDLIST}" ]; then
                echo "[ffuf] running (capped wordlist) – only enable for targeted runs"
                while read -r h; do
                  ffuf -w "${FFUF_WORDLIST}" -u "https://$h/FUZZ" -mc 200,301 -t 40 -o "outputs/ffuf.$h.$partname.json" || true
                done < "tmp/top_live_hosts.$partname.txt" || true
              else
                echo "::warning:: ffuf wordlist missing; skipping ffuf"
              fi
            fi

            # FIXED: point to the repository's protocol subfolders (http/...) not root
            TEMPLATE_ARGS="-t ${TMP_NUCLEI}/http/takeovers -t ${TMP_NUCLEI}/http/exposures -t ${TMP_NUCLEI}/http/misconfiguration"
            if [ "${AGGR}" = "true" ]; then
              TEMPLATE_ARGS="${TEMPLATE_ARGS} -t ${TMP_NUCLEI}/http/vulnerabilities -t ${TMP_NUCLEI}/http/cves"
            fi

            echo "[nuclei] running on live hosts $partname (templates: ${AGGR})"
            if [ -s "tmp/top_live_hosts.$partname.txt" ] && [ -d "${TMP_NUCLEI}" ]; then
              nuclei -l "tmp/top_live_hosts.$partname.txt" ${TEMPLATE_ARGS} -severity medium,high,critical --rate-limit "${RATE}" -jsonl -o "outputs/nuclei.$partname.jsonl" || true
            else
              echo "no live hosts or templates missing for this chunk"
            fi
            sleep 2
          done

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: findings
          path: outputs/**
